"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateConfig = exports.getElectronVersion = exports.getConfig = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

let doLoadConfig = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (configFile, projectDir) {
        const data = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(configFile, "utf8");
        let result;
        if (configFile.endsWith(".json5") || configFile.endsWith(".json")) {
            result = (_json || _load_json()).default.parse(data);
        } else if (configFile.endsWith(".toml")) {
            result = require("toml").parse(data);
        } else {
            result = (0, (_jsYaml || _load_jsYaml()).safeLoad)(data);
        }
        const relativePath = _path.relative(projectDir, configFile);
        (0, (_electronBuilderUtil || _load_electronBuilderUtil()).log)(`Using ${relativePath.startsWith("..") ? configFile : relativePath} configuration file`);
        return result;
    });

    return function doLoadConfig(_x, _x2) {
        return _ref.apply(this, arguments);
    };
})();

let loadConfig = (() => {
    var _ref2 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir, packageMetadata) {
        let data = getConfigFromPackageData(packageMetadata || (yield (0, (_promise || _load_promise()).orNullIfFileNotExist)((0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(projectDir, "package.json")))));
        if (data != null) {
            return data;
        }
        for (const configFile of ["electron-builder.yml", "electron-builder.yaml", "electron-builder.json", "electron-builder.json5", "electron-builder.toml"]) {
            data = yield (0, (_promise || _load_promise()).orNullIfFileNotExist)(doLoadConfig(_path.join(projectDir, configFile), projectDir));
            if (data != null) {
                return data;
            }
        }
        return null;
    });

    return function loadConfig(_x3, _x4) {
        return _ref2.apply(this, arguments);
    };
})();
/** @internal */


let getConfig = exports.getConfig = (() => {
    var _ref3 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (projectDir, configPath, packageMetadata, configFromOptions) {
        let fileOrPackageConfig;
        if (configPath == null) {
            fileOrPackageConfig = packageMetadata == null ? null : yield loadConfig(projectDir, packageMetadata);
        } else {
            fileOrPackageConfig = yield doLoadConfig(_path.resolve(projectDir, configPath), projectDir);
        }
        let config = (0, (_deepAssign || _load_deepAssign()).deepAssign)(fileOrPackageConfig == null ? Object.create(null) : fileOrPackageConfig, configFromOptions);
        if (config.extends == null && config.extends !== null && packageMetadata != null) {
            const devDependencies = packageMetadata.devDependencies;
            if (devDependencies != null && "react-scripts" in devDependencies) {
                config.extends = "react-cra";
            }
        }
        if (config.extends === "react-cra") {
            return (0, (_deepAssign || _load_deepAssign()).deepAssign)((yield (0, (_rectCra || _load_rectCra()).reactCra)(projectDir)), config);
        } else {
            return config;
        }
    });

    return function getConfig(_x5, _x6, _x7, _x8) {
        return _ref3.apply(this, arguments);
    };
})();
/** @internal */


let getElectronVersion = exports.getElectronVersion = (() => {
    var _ref4 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (config, projectDir, projectMetadata) {
        // build is required, but this check is performed later, so, we should check for null
        if (config != null && config.electronVersion != null) {
            return config.electronVersion;
        }
        // projectMetadata passed only for prepacked app asar and in this case no dev deps in the app.asar
        if (projectMetadata == null) {
            for (const name of ["electron", "electron-prebuilt", "electron-prebuilt-compile"]) {
                try {
                    return (yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(projectDir, "node_modules", name, "package.json"))).version;
                } catch (e) {
                    if (e.code !== "ENOENT") {
                        (0, (_electronBuilderUtil || _load_electronBuilderUtil()).warn)(`Cannot read electron version from ${name} package.json: ${e.message}`);
                    }
                }
            }
        }
        const packageJsonPath = _path.join(projectDir, "package.json");
        const electronPrebuiltDep = findFromElectronPrebuilt(projectMetadata || (yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(packageJsonPath)));
        if (electronPrebuiltDep == null) {
            try {
                const releaseInfo = yield (_nodeHttpExecutor || _load_nodeHttpExecutor()).httpExecutor.request({
                    hostname: "github.com",
                    path: "/electron/electron/releases/latest",
                    headers: {
                        Accept: "application/json"
                    }
                }, new (_electronBuilderHttp || _load_electronBuilderHttp()).CancellationToken());
                return releaseInfo.tag_name.startsWith("v") ? releaseInfo.tag_name.substring(1) : releaseInfo.tag_name;
            } catch (e) {
                (0, (_electronBuilderUtil || _load_electronBuilderUtil()).warn)(e);
            }
            throw new Error(`Cannot find electron dependency to get electron version in the '${packageJsonPath}'`);
        }
        const firstChar = electronPrebuiltDep[0];
        return firstChar === "^" || firstChar === "~" ? electronPrebuiltDep.substring(1) : electronPrebuiltDep;
    });

    return function getElectronVersion(_x9, _x10, _x11) {
        return _ref4.apply(this, arguments);
    };
})();

let createConfigValidator = (() => {
    var _ref5 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
        const ajv = new (_ajv || _load_ajv()).default({ allErrors: true });
        ajv.addMetaSchema(require("ajv/lib/refs/json-schema-draft-04.json"));
        require("ajv-keywords")(ajv, ["typeof"]);
        const schema = yield (0, (_fsExtraP || _load_fsExtraP()).readJson)(_path.join(__dirname, "..", "..", "scheme.json"));
        return ajv.compile(schema);
    });

    return function createConfigValidator() {
        return _ref5.apply(this, arguments);
    };
})();
/** @internal */


let validateConfig = exports.validateConfig = (() => {
    var _ref6 = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (config) {
        const extraMetadata = config.extraMetadata;
        if (extraMetadata != null) {
            if (extraMetadata.build != null) {
                throw new Error(`--em.build is deprecated, please specify as -c"`);
            }
            if (extraMetadata.directories != null) {
                throw new Error(`--em.directories is deprecated, please specify as -c.directories"`);
            }
        }
        if (validatorPromise == null) {
            validatorPromise = createConfigValidator();
        }
        const validator = yield validatorPromise;
        if (!validator(config)) {
            (0, (_electronBuilderUtil || _load_electronBuilderUtil()).debug)(JSON.stringify(validator.errors, null, 2));
            throw new Error(`Config is invalid:
${JSON.stringify(normaliseErrorMessages(validator.errors), null, 2)}

How to fix:
  1. Open https://github.com/electron-userland/electron-builder/wiki/Options
  2. Search the option name on the page.
    * Not found? The option was deprecated or not exists (check spelling).
    * Found? Check that the option in the appropriate place. e.g. "title" only in the "dmg", not in the root.
`);
        }
    });

    return function validateConfig(_x12) {
        return _ref6.apply(this, arguments);
    };
})();

var _ajv;

function _load_ajv() {
    return _ajv = _interopRequireDefault(require("ajv"));
}

var _electronBuilderHttp;

function _load_electronBuilderHttp() {
    return _electronBuilderHttp = require("electron-builder-http");
}

var _electronBuilderUtil;

function _load_electronBuilderUtil() {
    return _electronBuilderUtil = require("electron-builder-util");
}

var _deepAssign;

function _load_deepAssign() {
    return _deepAssign = require("electron-builder-util/out/deepAssign");
}

var _nodeHttpExecutor;

function _load_nodeHttpExecutor() {
    return _nodeHttpExecutor = require("electron-builder-util/out/nodeHttpExecutor");
}

var _promise;

function _load_promise() {
    return _promise = require("electron-builder-util/out/promise");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}

var _json;

function _load_json() {
    return _json = _interopRequireDefault(require("json5"));
}

var _path = _interopRequireWildcard(require("path"));

var _rectCra;

function _load_rectCra() {
    return _rectCra = require("../presets/rectCra");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getConfigFromPackageData(metadata) {
    return metadata == null ? null : metadata.build;
}

function findFromElectronPrebuilt(packageData) {
    for (const name of ["electron", "electron-prebuilt", "electron-prebuilt-compile"]) {
        const devDependencies = packageData.devDependencies;
        let dep = devDependencies == null ? null : devDependencies[name];
        if (dep == null) {
            const dependencies = packageData.dependencies;
            dep = dependencies == null ? null : dependencies[name];
        }
        if (dep != null) {
            return dep;
        }
    }
    return null;
}
let validatorPromise = null;

function normaliseErrorMessages(errors) {
    const result = Object.create(null);
    for (const e of errors) {
        if (e.keyword === "type" && e.params.type === "null") {
            // ignore - no sense to report that type accepts null
            continue;
        }
        const dataPath = e.dataPath.length === 0 ? [] : e.dataPath.substring(1).split(".");
        if (e.keyword === "additionalProperties") {
            dataPath.push(e.params.additionalProperty);
        }
        let o = result;
        let lastName = null;
        for (const p of dataPath) {
            if (p === dataPath[dataPath.length - 1]) {
                lastName = p;
                break;
            } else {
                if (o[p] == null) {
                    o[p] = Object.create(null);
                } else if (typeof o[p] === "string") {
                    o[p] = [o[p]];
                }
                o = o[p];
            }
        }
        if (lastName == null) {
            lastName = "unknown";
        }
        let message = e.message.toUpperCase()[0] + e.message.substring(1);
        switch (e.keyword) {
            case "additionalProperties":
                message = "Unknown option";
                break;
            case "required":
                message = "Required option";
                break;
            case "anyOf":
                message = "Invalid option object";
                break;
        }
        if (o[lastName] != null && !Array.isArray(o[lastName])) {
            o[lastName] = [o[lastName]];
        }
        if (Array.isArray(o[lastName])) {
            o[lastName].push(message);
        } else {
            o[lastName] = message;
        }
    }
    return result;
}
//# sourceMappingURL=config.js.map